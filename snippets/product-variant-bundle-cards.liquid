{%- comment -%}
  Bundle cards option renderer (last-level, type-aware)
  - Keeps original structure and qty derivation.
  - Prices and savings are computed against the currently selected upper-level options (same "type").
  - Baseline single price = price of the variant in the filtered set whose derived qty == 1
    (fallback: min price in the filtered set; fallback: product.price_min).
  - Save% = floor(100 - (variant_price*100) / (qty*single_price)).
{%- endcomment -%}

{%- assign position = option.position -%}

{%- comment -%}
  Read current upper-level selections from the selected_or_first_available_variant.
  Dawn re-renders the section on selection changes, so this stays in sync.
{%- endcomment -%}
{%- assign sel = product.selected_or_first_available_variant -%}
{%- assign sel_o1 = sel.option1 -%}
{%- assign sel_o2 = sel.option2 -%}
{%- assign sel_o3 = sel.option3 -%}

{%- comment -%}
  Compute single_price for the current "type" (upper-level selections) without building arrays.
  We scan all variants, keep the minimum price within the filtered set,
  and prefer the first with qty == 1 at the current position.
{%- endcomment -%}
{%- assign single_variant_price = null -%}
{%- assign min_price_in_type = null -%}

{%- for v in product.variants -%}
  {%- assign ok = true -%}
  {%- if position != 1 and sel_o1 and v.option1 != sel_o1 -%}{%- assign ok = false -%}{%- endif -%}
  {%- if position != 2 and sel_o2 and v.option2 != sel_o2 -%}{%- assign ok = false -%}{%- endif -%}
  {%- if position != 3 and sel_o3 and v.option3 != sel_o3 -%}{%- assign ok = false -%}{%- endif -%}
  {%- if ok -%}
    {%- comment -%} derive qty from the text of the option at the current position {%- endcomment -%}
    {%- assign ov = '' -%}
    {%- case position -%}
      {%- when 1 -%}
        {%- assign ov = v.option1 -%}
      {%- when 2 -%}
        {%- assign ov = v.option2 -%}
      {%- when 3 -%}
        {%- assign ov = v.option3 -%}
    {%- endcase -%}

    {%- assign lc = ov | downcase -%}
    {%- assign words = lc | replace: '-', ' ' | split: ' ' -%}
    {%- assign q = 0 -%}
    {%- for w in words -%}
      {%- assign t = w
        | remove: ','
        | remove: '.'
        | remove: '('
        | remove: ')'
        | remove: 'x'
        | remove: 'pack'
        | remove: 'case'
        | strip
      -%}
      {%- assign n = t | plus: 0 -%}
      {%- if n > q -%}{%- assign q = n -%}{%- endif -%}
    {%- endfor -%}
    {%- if q == 0 -%}{%- assign q = 1 -%}{%- endif -%}

    {%- if min_price_in_type == null or v.price < min_price_in_type -%}
      {%- assign min_price_in_type = v.price -%}
    {%- endif -%}

    {%- if single_variant_price == null and q == 1 -%}
      {%- assign single_variant_price = v.price -%}
    {%- endif -%}
  {%- endif -%}
{%- endfor -%}

{%- assign single_price = single_variant_price | default: min_price_in_type | default: product.price_min -%}

<div class="bundle-cards" data-single-price="{{ single_price }}">
  <div class="bundle-cards__grid">
    {%- for value in option.values -%}
      {%- assign value_text = value -%}
      {%- if value.value -%}{%- assign value_text = value.value -%}{%- endif -%}

      {%- assign input_id = section_id
        | append: '-'
        | append: option.position
        | append: '-'
        | append: forloop.index0
      -%}
      {%- assign input_name = option.name | append: '-' | append: option.position -%}

      {%- comment -%}
        Find the matching variant within the same "type" (upper-level selections),
        i.e., same option1/2/3 except at the current position which must equal value_text.
      {%- endcomment -%}
      {%- assign match_variant = null -%}
      {%- for v in product.variants -%}
        {%- assign ok = true -%}
        {%- if position != 1 and sel_o1 and v.option1 != sel_o1 -%}{%- assign ok = false -%}{%- endif -%}
        {%- if position != 2 and sel_o2 and v.option2 != sel_o2 -%}{%- assign ok = false -%}{%- endif -%}
        {%- if position != 3 and sel_o3 and v.option3 != sel_o3 -%}{%- assign ok = false -%}{%- endif -%}
        {%- if ok -%}
          {%- assign ov = '' -%}
          {%- case position -%}
            {%- when 1 -%}
              {%- assign ov = v.option1 -%}
            {%- when 2 -%}
              {%- assign ov = v.option2 -%}
            {%- when 3 -%}
              {%- assign ov = v.option3 -%}
          {%- endcase -%}
          {%- if ov == value_text -%}
            {%- assign match_variant = v -%}
            {%- break -%}
          {%- endif -%}
        {%- endif -%}
      {%- endfor -%}

      {%- assign option_disabled = true -%}
      {%- if value.available and match_variant and match_variant.available -%}
        {%- assign option_disabled = false -%}
      {%- endif -%}

      {%- comment -%} Derive qty from the value text (same logic as original) {%- endcomment -%}
      {%- assign lc = value_text | downcase -%}
      {%- assign words = lc | replace: '-', ' ' | split: ' ' -%}
      {%- assign qty = 0 -%}
      {%- for w in words -%}
        {%- assign t = w
          | remove: ','
          | remove: '.'
          | remove: '('
          | remove: ')'
          | remove: 'x'
          | remove: 'pack'
          | remove: 'case'
          | strip
        -%}
        {%- assign n = t | plus: 0 -%}
        {%- if n > qty -%}{%- assign qty = n -%}{%- endif -%}
      {%- endfor -%}
      {%- if qty == 0 -%}{%- assign qty = 1 -%}{%- endif -%}

      {%- assign v_price = match_variant.price | default: null -%}
      {%- assign is_checked = false -%}
      {%- if value.selected -%}{%- assign is_checked = true -%}{%- endif -%}

      {%- comment -%} Save% against qty * single_price of THIS type {%- endcomment -%}
      {%- assign save_pct = 0 -%}
      {%- assign denom = qty | times: single_price -%}
      {%- if v_price and qty > 1 and denom > 0 and v_price < denom -%}
        {%- assign diff = denom | minus: v_price -%}
        {%- assign save_pct = diff | times: 100 | divided_by: denom -%}
        {%- assign save_pct = save_pct | at_least: 0 -%}
      {%- endif -%}

      <input
        class="bundle-card__input visually-hidden"
        type="radio"
        id="{{ input_id }}"
        name="{{ input_name | escape }}"
        value="{{ value_text | escape }}"
        form="{{ product_form_id }}"
        data-product-url="{{ value.product_url }}"
        data-option-value-id="{{ value.id }}"
        {% if is_checked %}
          checked
        {% endif %}
        {% if option_disabled %}
          disabled
        {% endif %}
        data-qty="{{ qty }}"
        {% if match_variant %}
          data-variant-id="{{ match_variant.id }}"
        {% endif %}
        {% if v_price %}
          data-variant-price="{{ v_price }}"
        {% endif %}
      >

      <label
        class="bundle-card{% if is_checked %} is-active{% endif %}{% if option_disabled %} is-disabled{% endif %}"
        for="{{ input_id }}"
      >
        {%- if qty > 1 and save_pct > 0 -%}
          <span class="bundle-card__badge">Save {{ save_pct }}%</span>
        {%- endif -%}
        <span class="bundle-card__title">{{ value_text }}</span>
        <span class="bundle-card__price">
          {%- if v_price -%}{{ v_price | money }}{%- else -%}—{%- endif -%}
        </span>
        <span class="visually-hidden label-unavailable">
          {{- 'products.product.variant_sold_out_or_unavailable' | t -}}
        </span>
      </label>
    {%- endfor -%}
  </div>
</div>

<style>
  /* --- grid --- */
  .product-form__input--bundle-cards .bundle-cards__grid{
    display:grid; gap:14px;
    grid-template-columns: repeat(3, minmax(0,128px));
  }
  @media (max-width: 990px){ .product-form__input--bundle-cards .bundle-cards__grid{ grid-template-columns: repeat(2,128px); } }
  @media (max-width: 540px){ .product-form__input--bundle-cards .bundle-cards__grid{ grid-template-columns: 128px; } }

  /* --- card --- */
  .product-form__input--bundle-cards .bundle-card{
    font-family: Roboto, sans-serif;
    font-size: 16px;
    width:128px;
    height:128px;
    position:relative;
    display:grid; gap:.35rem;
    padding:30px 10px;
    border-radius:14px;
    border:2px solid #e5e7eb;
    background:#fff;
    cursor:pointer;
    text-align:center;
  }
  .product-form__input--bundle-cards .bundle-card.is-active{
    background:#2f2f2f; color:#fff; border-color:#2f2f2f;
  }
  .product-form__input--bundle-cards .bundle-card.is-disabled{ opacity:.5; cursor:not-allowed; }
  .product-form__input--bundle-cards .bundle-card__title{ font-weight:600; }
  .product-form__input--bundle-cards .bundle-card__price{ font-weight:400; }
  .product-form__input--bundle-cards .bundle-card__badge{
    position:absolute;
    top:-10px; left:50%;
    transform: translateX(-50%);
    background:#4d7c0f; color:#fff;
    font-weight:500; font-size:14px; line-height:1;
    padding:6px 10px; border-radius:999px;
    white-space: nowrap;
  }

  /* strike inside main price (main product price area) */
  #price-{{ section_id }} .bundle-unit-strike{
    text-decoration: line-through;
    opacity:.6;
    margin-right:.5rem;
    display:inline-block;
  }
</style>

<script>
  (function () {
    const fieldset = document.currentScript.closest('[data-bundle-cards]');
    if (!fieldset || fieldset.dataset.bundleInit === '1') return;
    fieldset.dataset.bundleInit = '1';

    const container = fieldset.querySelector('.bundle-cards');
    const priceRoot = document.getElementById('price-{{ section_id }}');
    if (!priceRoot) return;

    // --- helpers (idénticos a tu versión) ---
    function isVisible(el) {
      return !!(el && el.offsetParent !== null);
    }
    function getVisiblePriceNode() {
      const sale = priceRoot.querySelector('.price__sale .price-item--last');
      if (sale && isVisible(sale)) return sale;
      const regular = priceRoot.querySelector('.price__regular .price-item--regular');
      if (regular && isVisible(regular)) return regular;
      return sale || regular || null;
    }
    function getOrCreateStrike() {
      let s = priceRoot.querySelector('.bundle-unit-strike[data-bundle-strike="1"]');
      if (!s) {
        s = document.createElement('span');
        s.className = 'bundle-unit-strike';
        s.setAttribute('data-bundle-strike', '1');
        s.style.display = 'none';
      }
      return s;
    }
    function placeStrikeBefore(target, strike) {
      if (!target || !strike) return;
      const parent = target.parentNode;
      if (strike.parentNode !== parent || strike.nextSibling !== target) {
        parent.insertBefore(strike, target);
      }
    }
    function activeInput() {
      return fieldset.querySelector('input.bundle-card__input:checked');
    }
    function updateSelectedLegend() {
      const sel = fieldset.querySelector('[data-selected-value]');
      const inp = activeInput();
      if (sel && inp) sel.textContent = inp.value;
    }
    // Tu qty robusto. Si ya usas deriveQtyFromString, puedes dejarlo igual:
    function qtyFromInput(input) {
      const v = input?.getAttribute('data-qty');
      if (v && !isNaN(parseInt(v, 10))) return Math.max(1, parseInt(v, 10));
      const s = String(input?.value || '').toLowerCase();
      const nums = s.match(/\d+/g);
      if (nums?.length) return Math.max(...nums.map((n) => parseInt(n, 10)));
      if (s.includes('single')) return 1;
      return 1;
    }
    function moneyLike(cents) {
      const target = getVisiblePriceNode();
      const sample = (target?.textContent || '').trim();
      const match = sample.match(/[\d]+(?:[.,]\d{3})*(?:[.,]\d{2})?/);
      let prefix = '',
        suffix = '';
      if (match) {
        const i = sample.indexOf(match[0]);
        prefix = sample.slice(0, i);
        suffix = sample.slice(i + match[0].length);
      }
      const n = (cents / 100).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      return `${prefix}${n}${suffix}`.trim();
    }

    // --- NUEVO: recalcular singlePrice siempre a partir del DOM actual ---
    function getSinglePriceCents() {
      const inputs = Array.from(fieldset.querySelectorAll('input.bundle-card__input'));
      if (!inputs.length) {
        // último recurso: dataset (puede venir del Liquid)
        const ds = parseInt(container?.dataset.singlePrice || '0', 10);
        return isNaN(ds) ? 0 : ds;
      }

      // 1) prefer a card with qty==1
      const singleCard = inputs.find((inp) => qtyFromInput(inp) === 1 && inp.hasAttribute('data-variant-price'));
      if (singleCard) {
        const p = parseInt(singleCard.getAttribute('data-variant-price') || '0', 10);
        if (!isNaN(p) && p > 0) return p;
      }

      // 2) else, minimum price among visible cards
      let min = Infinity;
      for (const inp of inputs) {
        const p = parseInt(inp.getAttribute('data-variant-price') || '0', 10);
        if (!isNaN(p) && p > 0 && p < min) min = p;
      }
      if (min !== Infinity) return min;

      // 3) fallback: dataset
      const ds = parseInt(container?.dataset.singlePrice || '0', 10);
      return isNaN(ds) ? 0 : ds;
    }

    // --- actualización con guardas para evitar bucles (igual que tuyo) ---
    let rafId = 0;
    let isUpdating = false;
    function scheduleUpdate() {
      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(updateStrike);
    }

    function updateStrike() {
      if (isUpdating) return;
      isUpdating = true;

      try {
        const inp = activeInput();
        const target = getVisiblePriceNode();
        const strike = getOrCreateStrike();

        if (target) placeStrikeBefore(target, strike);

        if (!inp || !target) {
          strike.style.display = 'none';
          return;
        }

        // >>> AQUÍ EL CAMBIO CLAVE: recomputar singlePrice en cada update <<<
        const singlePrice = getSinglePriceCents();

        const qty = qtyFromInput(inp);
        const strikeTotal = qty > 1 ? qty * singlePrice : 0;

        if (strikeTotal > 0) {
          strike.textContent = moneyLike(strikeTotal);
          strike.style.display = 'inline-block';
        } else {
          strike.style.display = 'none';
        }

        // limpiar duplicados
        priceRoot
          .querySelectorAll('.bundle-unit-strike:not([data-bundle-strike="1"])')
          .forEach((n) => n.parentNode?.removeChild(n));
      } finally {
        requestAnimationFrame(() => {
          isUpdating = false;
        });
      }
    }

    // Eventos de interacción (igual que tuyo)
    fieldset.addEventListener('change', (e) => {
      if (e.target.matches('input.bundle-card__input')) {
        fieldset.querySelectorAll('.bundle-card').forEach((l) => l.classList.remove('is-active'));
        e.target.nextElementSibling?.classList.add('is-active');
        updateSelectedLegend();
        scheduleUpdate();
      }
    });

    // Disparar en cambios de variante (Dawn)
    const variantRoot = fieldset.closest('variant-selects');
    variantRoot?.addEventListener('change', scheduleUpdate);
    variantRoot?.addEventListener('variant:change', scheduleUpdate);

    // Observar el precio principal
    const moPrice = priceRoot ? new MutationObserver(() => scheduleUpdate()) : null;
    moPrice?.observe(priceRoot, { childList: true, subtree: true, characterData: true });

    // NUEVO: observar también el fieldset por si Dawn re-renderiza las cards/precios
    const moCards = new MutationObserver(() => scheduleUpdate());
    moCards.observe(fieldset, { childList: true, subtree: true, characterData: true, attributes: true });

    // Primer pintado
    updateSelectedLegend();
    scheduleUpdate();
  })();
</script>
